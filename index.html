<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bug Palace - Sz√°ll√≠t√°si Lista</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin=""/>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; background: #f5f5f5; color: #333; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        header { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1 { font-size: 24px; margin-bottom: 10px; }
        .file-input-wrapper { display: inline-block; margin: 10px 0; }
        .file-input-label { display: inline-block; padding: 12px 24px; background: #4CAF50; color: white; border-radius: 6px; cursor: pointer; font-weight: 500; }
        .file-input-label:hover { background: #45a049; }
        input[type="file"] { display: none; }
        .file-name { margin-left: 15px; color: #666; }
        .main-content { display: grid; grid-template-columns: 400px 1fr; gap: 20px; }
        @media (max-width: 1024px) { .main-content { grid-template-columns: 1fr; } }
        .sidebar { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); max-height: calc(100vh - 200px); overflow-y: auto; }
        .filters { margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid #eee; }
        .filter-group label { display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px; }
        .checkbox-group { display: flex; flex-direction: column; gap: 8px; }
        .checkbox-item { display: flex; align-items: center; gap: 8px; }
        .checkbox-item input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }
        .checkbox-item label { font-weight: normal; cursor: pointer; }
        .stats { background: #f9f9f9; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 13px; }
        .stats-row { display: flex; justify-content: space-between; margin-bottom: 6px; }
        .stats-label { font-weight: 600; }
        .action-buttons { margin-bottom: 20px; display: flex; flex-direction: column; gap: 10px; }
        .btn { padding: 12px 20px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.3s; font-size: 14px; }
        .btn-primary { background: #2196F3; color: white; }
        .btn-primary:hover { background: #1976D2; }
        .btn-success { background: #4CAF50; color: white; }
        .btn-success:hover { background: #45a049; }
        .btn:disabled { background: #ccc; cursor: not-allowed; }
        .order-list { margin-top: 20px; }
        .order-item { padding: 12px; border: 1px solid #e0e0e0; border-radius: 6px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s; background: white; position: relative; }
        .order-item:hover { border-color: #4CAF50; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .order-item.has-order { border-color: #2196F3; background: #e3f2fd; }
        .order-item.geocoding-failed { background-color: #fff0f0; border-color: #e0b0b0; }
        .geocoding-error-message { font-size: 12px; color: #c0392b; font-weight: 600; margin-top: 8px; padding: 5px 8px; background: #fde2e2; border: 1px solid #e7c3c3; border-radius: 4px; text-align: center; }
        .order-number-badge { position: absolute; top: 8px; right: 8px; background: #2196F3; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 14px; }
        .order-status { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 600; margin-bottom: 6px; }
        .status-teljesitve { background: #C6EFCE; color: #155724; }
        .status-feldolgozas { background: #FFEB9C; color: #856404; }
        .status-fizetes-folyamatban { background: #DDEBF7; color: #004085; }
        .status-fizetes-elott { background: #FFC7CE; color: #721c24; }
        .order-name { font-weight: 600; margin-bottom: 4px; }
        .order-phone { font-size: 13px; color: #666; margin-bottom: 4px; }
        
        /* √öJ: C√≠mszegment√°l√°s st√≠lusok */
        .address-segments { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 6px; }
        .address-field { display: flex; flex-direction: column; }
        .address-field.full-width { grid-column: 1 / -1; }
        .address-label { font-size: 10px; color: #999; text-transform: uppercase; font-weight: 600; margin-bottom: 2px; }
        .address-input { padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; font-family: inherit; }
        .address-input:focus { outline: none; border-color: #2196F3; background: #f9f9f9; }
        .address-display { font-size: 13px; color: #666; padding: 6px; background: #f9f9f9; border-radius: 4px; margin-top: 4px; }
        
        .order-actions { margin-top: 8px; display: flex; gap: 10px; flex-wrap: wrap; }
        .btn-regeocode { padding: 6px 12px; font-size: 12px; background: #f0f0f0; color: #333; border: 1px solid #ccc; }
        .btn-regeocode:hover { background: #e0e0e0; }
        .btn-toggle-edit { padding: 6px 12px; font-size: 12px; background: #2196F3; color: white; border: none; }
        .btn-toggle-edit:hover { background: #1976D2; }
        .order-time { font-size: 13px; color: #FF9800; font-weight: 600; background: #FFF3E0; padding: 4px 8px; border-radius: 4px; display: inline-block; margin-top: 6px; }
        .order-maps-link { display: inline-block; padding: 6px 12px; background: #4285F4; color: white; text-decoration: none; border-radius: 4px; font-size: 12px; font-weight: 600; transition: all 0.2s; }
        .order-maps-link:hover { background: #1976D2; }
        .map-container { background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); overflow: hidden; position: relative; }
        #map { height: calc(100vh - 200px); min-height: 500px; width: 100%; z-index: 1; }
        .no-data { text-align: center; padding: 40px; color: #999; }
        .progress-bar { width: 100%; height: 6px; background: #e0e0e0; border-radius: 3px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: #4CAF50; transition: width 0.3s; }
        .info-box { background: #e3f2fd; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 13px; color: #1976d2; }
        .warning-box { background: #fff3cd; padding: 12px; border-radius: 6px; margin-bottom: 15px; font-size: 13px; color: #856404; border: 1px solid #ffeaa7; }
        .loading-overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.9); display: flex; align-items: center; justify-content: center; z-index: 1000; font-size: 14px; color: #666; }
        .edit-mode { background: #fffef0; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üêõ Bug Palace - Sz√°ll√≠t√°si Lista (v2.0)</h1>
            <p>T√∂ltsd fel a WooCommerce export f√°jlt, szerkeszd a c√≠meket szegment√°ltan!</p>
            <div style="margin-top: 15px;">
                <div class="file-input-wrapper">
                    <label class="file-input-label" for="file-upload">üìÅ WooCommerce Excel kiv√°laszt√°sa</label>
                    <input type="file" id="file-upload" accept=".xlsx, .xls">
                </div>
                <span class="file-name" id="file-name">Nincs f√°jl kiv√°lasztva</span>
            </div>
        </header>
        <div class="main-content">
            <div class="sidebar">
                <div class="filters">
                    <div class="filter-group">
                        <label>Rendel√©s st√°tusza:</label>
                        <div class="checkbox-group">
                            <div class="checkbox-item"><input type="checkbox" id="status-teljesitve" value="Teljes√≠tve"><label for="status-teljesitve">Teljes√≠tve</label></div>
                            <div class="checkbox-item"><input type="checkbox" id="status-feldolgozas" value="Feldolgoz√°s alatt" checked><label for="status-feldolgozas">Feldolgoz√°s alatt</label></div>
                            <div class="checkbox-item"><input type="checkbox" id="status-fizetes-folyamatban" value="Fizet√©s folyamatban" checked><label for="status-fizetes-folyamatban">Fizet√©s folyamatban</label></div>
                            <div class="checkbox-item"><input type="checkbox" id="status-fizetes-elott" value="Fizet√©s el≈ëtt" checked><label for="status-fizetes-elott">Fizet√©s el≈ëtt</label></div>
                        </div>
                    </div>
                </div>
                <div class="warning-box">‚ö†Ô∏è <strong>Fontos:</strong> Csak a bejel√∂lt st√°tusz√∫ rendel√©sek lesznek geok√≥dolva!</div>
                <div class="info-box">üí° <strong>√öj funkci√≥:</strong> Kattints a "C√≠m szerkeszt√©se" gombra, majd t√∂ltsd ki a mez≈ëket pontosan. Az "√öjrak√≥dol√°s" gomb friss√≠ti a t√©rk√©pet.</div>
                <div class="stats" id="stats">
                    <div class="stats-row"><span class="stats-label">√ñsszes rendel√©s:</span><span id="total-orders">0</span></div>
                    <div class="stats-row"><span class="stats-label">Geok√≥dolt:</span><span id="geocoded-count">0</span></div>
                    <div class="stats-row"><span class="stats-label">Sorrendbe rakva:</span><span id="ordered-count">0</span></div>
                </div>
                <div class="action-buttons">
                    <button class="btn btn-success" id="calculate-route-btn" disabled>üó∫Ô∏è √ötvonal optimaliz√°l√°sa</button>
                    <button class="btn btn-primary" id="copy-list-btn" disabled>üìã Lista m√°sol√°sa</button>
                    <button class="btn btn-primary" id="export-csv-btn" disabled>üíæ CSV export√°l√°s</button>
                </div>
                <div class="order-list" id="order-list" style="position: relative;">
                    <div class="no-data">T√∂lts fel egy WooCommerce export f√°jlt a kezd√©shez</div>
                </div>
            </div>
            <div class="map-container">
                <div id="map"></div>
            </div>
        </div>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    
    <script>
        let map, markers = [], routePolyline = null, orders = [], orderedStops = [], routeTimes = {};
        let editingOrder = null; // √öJ: Melyik rendel√©st szerkesztj√ºk
        
        function initMap() {
            map = L.map('map').setView([47.1625, 19.5033], 7);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
                attribution: '¬© OpenStreetMap contributors', 
                maxZoom: 19 
            }).addTo(map);
        }
        
        function getStatusClass(status) {
            const statusMap = { 
                'Teljes√≠tve': 'status-teljesitve', 
                'Feldolgoz√°s alatt': 'status-feldolgozas', 
                'Fizet√©s folyamatban': 'status-fizetes-folyamatban', 
                'Fizet√©s el≈ëtt': 'status-fizetes-elott' 
            };
            return statusMap[status] || 'status-feldolgozas';
        }
        
        function getSelectedStatuses() {
            return Array.from(document.querySelectorAll('.checkbox-group input:checked')).map(cb => cb.value);
        }
        
        function findColumn(columns, keywords) {
            return columns.find(col => keywords.every(kw => col.toLowerCase().includes(kw.toLowerCase())));
        }
        
        // √öJ: C√≠m sz√©tbont√°sa komponensekre
        function parseAddress(fullAddress) {
            const parts = fullAddress.split(',').map(s => s.trim());
            const result = { street: '', city: '', postcode: '' };
            
            parts.forEach(part => {
                // Ir√°ny√≠t√≥sz√°m detekt√°l√°s (4 sz√°mjegy)
                if (/^\d{4}$/.test(part)) {
                    result.postcode = part;
                }
                // Budapest vagy m√°s v√°ros
                else if (part.toLowerCase().includes('budapest') || /^[A-Z√Å√â√ç√ì√ñ≈ê√ö√ú≈∞][a-z√°√©√≠√≥√∂≈ë√∫√º≈±]+$/.test(part)) {
                    result.city = part;
                }
                // Utca + h√°zsz√°m
                else if (part.length > 0) {
                    result.street = part;
                }
            });
            
            return result;
        }
        
        // √öJ: C√≠mkomponensek √∂sszerak√°sa
        function buildFullAddress(segments) {
            const parts = [];
            if (segments.street) parts.push(segments.street);
            if (segments.city) parts.push(segments.city);
            if (segments.postcode) parts.push(segments.postcode);
            return parts.join(', ');
        }
        
        function processRawWooCommerce(rawData) {
            const columns = Object.keys(rawData[0]);
            const colMap = {
                num: findColumn(columns, ['order', 'number']), 
                status: findColumn(columns, ['status']),
                fName: findColumn(columns, ['first', 'shipping']), 
                lName: findColumn(columns, ['last', 'shipping']),
                addr: findColumn(columns, ['address', 'shipping']), 
                city: findColumn(columns, ['city', 'shipping']),
                postcode: findColumn(columns, ['postcode', 'shipping']), 
                phone: findColumn(columns, ['phone', 'shipping']) || findColumn(columns, ['phone', 'billing'])
            };
            
            const grouped = {};
            rawData.forEach(row => {
                const orderNum = row[colMap.num];
                if (!orderNum || grouped[orderNum]) return;
                
                const addressParts = [];
                if (row[colMap.addr]) addressParts.push(String(row[colMap.addr]).trim());
                if (row[colMap.city]) {
                    let city = String(row[colMap.city]).trim();
                    if (city.toLowerCase().includes('budapest')) city = 'Budapest';
                    addressParts.push(city);
                }
                if (row[colMap.postcode]) addressParts.push(row[colMap.postcode]);
                
                const fullAddress = addressParts.join(', ');
                
                grouped[orderNum] = {
                    orderNumber: orderNum, 
                    status: row[colMap.status], 
                    name: `${row[colMap.lName] || ''} ${row[colMap.fName] || ''}`.trim(),
                    phone: colMap.phone ? row[colMap.phone] : '', 
                    address: fullAddress,
                    addressSegments: parseAddress(fullAddress) // √öJ: Szegment√°lt c√≠m ment√©se
                };
            });
            
            return Object.values(grouped);
        }
        
        async function geocodeAddress(address) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address + ', Hungary')}&limit=1`);
                const data = await response.json();
                if (data && data.length > 0) {
                    return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) };
                }
            } catch (error) { 
                console.error('Geocoding error:', error); 
            }
            return null;
        }
        
        document.getElementById('file-upload').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            document.getElementById('file-name').textContent = file.name;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const rawData = XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]);
                    
                    document.getElementById('order-list').innerHTML = '<div class="no-data">Rendel√©sek feldolgoz√°sa...</div>';
                    orders = processRawWooCommerce(rawData);
                    
                    const ordersToGeocode = orders.filter(order => getSelectedStatuses().includes(order.status));
                    
                    const progressDiv = document.createElement('div');
                    progressDiv.className = 'no-data';
                    progressDiv.innerHTML = `<div>C√≠mek geok√≥dol√°sa...</div><div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div><div><span id="geocode-progress">0</span>/${ordersToGeocode.length}</div>`;
                    document.getElementById('order-list').innerHTML = '';
                    document.getElementById('order-list').appendChild(progressDiv);
                    
                    for (let i = 0; i < ordersToGeocode.length; i++) {
                        const order = ordersToGeocode[i];
                        const coords = await geocodeAddress(order.address);
                        if (coords) { 
                            order.lat = coords.lat; 
                            order.lon = coords.lon; 
                        }
                        
                        const progress = ((i + 1) / ordersToGeocode.length * 100).toFixed(0);
                        document.getElementById('progress-fill').style.width = progress + '%';
                        document.getElementById('geocode-progress').textContent = i + 1;
                        await new Promise(resolve => setTimeout(resolve, 1100));
                    }
                    
                    renderOrders(); 
                    updateMap(); 
                    updateStats();
                } catch (error) {
                    console.error('Error processing file:', error);
                    document.getElementById('order-list').innerHTML = '<div class="no-data" style="color: red;">Hiba a f√°jl feldolgoz√°sa sor√°n!</div>';
                }
            };
            reader.readAsArrayBuffer(file);
        });
        
        function getFilteredOrders() {
            return orders.filter(order => getSelectedStatuses().includes(order.status));
        }
        
        function getOrderPosition(orderNumber) {
            const index = orderedStops.indexOf(orderNumber);
            return index !== -1 ? index + 1 : null;
        }
        
        function toggleOrderSequence(orderNumber) {
            const order = orders.find(o => o.orderNumber === orderNumber);
            if (!order || !order.lat || !order.lon) return;
            
            const index = orderedStops.indexOf(orderNumber);
            if (index !== -1) { 
                orderedStops.splice(index, 1); 
            } else { 
                orderedStops.push(orderNumber); 
            }
            
            renderOrders(); 
            updateMap(); 
            updateStats();
        }

        // √öJ: C√≠m szerkeszt√©si m√≥d kapcsol√°sa
        function toggleEditMode(orderNumber) {
            editingOrder = editingOrder === orderNumber ? null : orderNumber;
            renderOrders();
        }

        // √öJ: Szerkeszt√©s ut√°n ment√©s
        function saveAddressEdit(orderNumber) {
            const order = orders.find(o => o.orderNumber === orderNumber);
            if (!order) return;
            
            // √ñsszes input mez≈ë √©rt√©k√©nek kiolvas√°sa
            const street = document.getElementById(`street-${orderNumber}`).value.trim();
            const city = document.getElementById(`city-${orderNumber}`).value.trim();
            const postcode = document.getElementById(`postcode-${orderNumber}`).value.trim();
            
            order.addressSegments = { street, city, postcode };
            order.address = buildFullAddress(order.addressSegments);
            
            editingOrder = null;
            renderOrders();
        }

        async function reGeocodeSingleOrder(orderNumber, buttonElement) {
            const order = orders.find(o => o.orderNumber === orderNumber);
            if (!order) return;

            const originalButtonText = buttonElement.textContent;
            buttonElement.textContent = 'K√≥dol√°s...';
            buttonElement.disabled = true;

            // Ha szerkeszt√©si m√≥dban van, mentj√ºk az adatokat
            if (editingOrder === orderNumber) {
                saveAddressEdit(orderNumber);
            }

            const coords = await geocodeAddress(order.address);
            if (coords) {
                order.lat = coords.lat;
                order.lon = coords.lon;
            } else {
                delete order.lat;
                delete order.lon;
                const indexInStops = orderedStops.indexOf(orderNumber);
                if (indexInStops > -1) orderedStops.splice(indexInStops, 1);
            }

            buttonElement.textContent = originalButtonText;
            buttonElement.disabled = false;
            renderOrders(); 
            updateMap(); 
            updateStats();
        }
        
        function renderOrders() {
            const orderList = document.getElementById('order-list');
            const filteredOrders = getFilteredOrders();
            
            if (filteredOrders.length === 0) {
                orderList.innerHTML = '<div class="no-data">Nincs megjelen√≠thet≈ë rendel√©s</div>'; 
                return;
            }
            
            orderList.innerHTML = '';
            
            const sortedOrders = [...filteredOrders].sort((a, b) => {
                const posA = getOrderPosition(a.orderNumber), posB = getOrderPosition(b.orderNumber);
                if (posA && posB) return posA - posB;
                if (posA) return -1; 
                if (posB) return 1; 
                return 0;
            });
            
            sortedOrders.forEach(order => {
                const orderDiv = document.createElement('div');
                orderDiv.className = 'order-item';
                const position = getOrderPosition(order.orderNumber);
                if (position) orderDiv.classList.add('has-order');
                
                const hasCoordinates = order.lat && order.lon;
                if (!hasCoordinates) orderDiv.classList.add('geocoding-failed');
                
                const isEditing = editingOrder === order.orderNumber;
                if (isEditing) orderDiv.classList.add('edit-mode');
                
                // C√≠mmegjelen√≠t√©s logika
                let addressHTML;
                if (isEditing) {
                    addressHTML = `
                        <div class="address-segments">
                            <div class="address-field full-width">
                                <span class="address-label">Utca + h√°zsz√°m</span>
                                <input type="text" class="address-input" id="street-${order.orderNumber}" value="${order.addressSegments.street || ''}" placeholder="pl. Andr√°ssy √∫t 1.">
                            </div>
                            <div class="address-field">
                                <span class="address-label">V√°ros</span>
                                <input type="text" class="address-input" id="city-${order.orderNumber}" value="${order.addressSegments.city || ''}" placeholder="pl. Budapest">
                            </div>
                            <div class="address-field">
                                <span class="address-label">Ir√°ny√≠t√≥sz√°m</span>
                                <input type="text" class="address-input" id="postcode-${order.orderNumber}" value="${order.addressSegments.postcode || ''}" placeholder="pl. 1061">
                            </div>
                        </div>
                    `;
                } else {
                    addressHTML = `<div class="address-display">üìç ${order.address}</div>`;
                }
                
                orderDiv.innerHTML = `
                    ${position ? `<div class="order-number-badge">${position}</div>` : ''}
                    <div class="order-status ${getStatusClass(order.status)}">${order.status}</div>
                    <div class="order-name">${order.name}</div>
                    <div class="order-phone">üìû ${order.phone}</div>
                    ${addressHTML}
                    ${!hasCoordinates ? '<div class="geocoding-error-message">‚ö†Ô∏è A c√≠m nem tal√°lhat√≥ a t√©rk√©pen!</div>' : ''}
                    <div class="order-actions">
                        <button class="btn btn-toggle-edit" data-ordernumber="${order.orderNumber}">
                            ${isEditing ? '‚úÖ Ment√©s' : '‚úèÔ∏è C√≠m szerkeszt√©se'}
                        </button>
                        <button class="btn btn-regeocode" data-ordernumber="${order.orderNumber}">üîÑ √öjrak√≥dol√°s</button>
                    </div>
                `;
                
                // Sorrendre kattint√°s - csak akkor, ha NEM szerkeszt√©si m√≥dban vagyunk
                orderDiv.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('btn') && 
                        !e.target.classList.contains('address-input') &&
                        !isEditing) {
                        toggleOrderSequence(order.orderNumber);
                    }
                });
                
                orderList.appendChild(orderDiv);
            });
        }
        
        // √öJ: Event delegation az √∂sszes dinamikus gombhoz
        document.getElementById('order-list').addEventListener('click', (e) => {
            // √öjrak√≥dol√°s gomb
            if (e.target.classList.contains('btn-regeocode')) {
                e.stopPropagation();
                const orderNumber = Number(e.target.dataset.ordernumber);
                reGeocodeSingleOrder(orderNumber, e.target);
            }
            
            // Szerkeszt√©s/Ment√©s gomb
            if (e.target.classList.contains('btn-toggle-edit')) {
                e.stopPropagation();
                const orderNumber = Number(e.target.dataset.ordernumber);
                
                if (editingOrder === orderNumber) {
                    // Ment√©s
                    saveAddressEdit(orderNumber);
                } else {
                    // Szerkeszt√©s ind√≠t√°sa
                    toggleEditMode(orderNumber);
                }
            }
        });
        
        function updateMap() {
            if (!map) return;
            
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            if (routePolyline) { map.removeLayer(routePolyline); routePolyline = null; }
            
            const geocodedOrders = getFilteredOrders().filter(o => o.lat && o.lon);
            if (geocodedOrders.length === 0) return;
            
            geocodedOrders.forEach(order => {
                const position = getOrderPosition(order.orderNumber);
                const color = { 
                    'Teljes√≠tve': 'green', 
                    'Feldolgoz√°s alatt': 'orange', 
                    'Fizet√©s folyamatban': 'blue', 
                    'Fizet√©s el≈ëtt': 'red' 
                }[order.status] || 'gray';
                
                const markerHtml = position
                    ? `<div style="background-color: ${color}; width: 32px; height: 32px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 6px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; color: white; font-weight: 700; font-size: 16px;">${position}</div>`
                    : `<div style="background-color: ${color}; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>`;
                
                const icon = L.divIcon({ 
                    className: 'custom-marker', 
                    html: markerHtml, 
                    iconSize: position ? [32, 32] : [12, 12] 
                });
                
                const marker = L.marker([order.lat, order.lon], { icon })
                    .bindPopup(`<strong>${order.name}</strong><br>üìû ${order.phone}<br>üìç ${order.address}`)
                    .addTo(map);
                
                marker.on('click', () => toggleOrderSequence(order.orderNumber));
                markers.push(marker);
            });
            
            if (markers.length > 0) {
                const group = L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.1));
            }
            
            // √öJ: √ötvonal rajzol√°sa, ha van legal√°bb 2 sorrendi pont
            if (orderedStops.length >= 2) {
                const orderedCoords = orderedStops
                    .map(orderNum => orders.find(o => o.orderNumber === orderNum))
                    .filter(o => o && o.lat && o.lon)
                    .map(o => [o.lat, o.lon]);
                
                if (orderedCoords.length >= 2) {
                    routePolyline = L.polyline(orderedCoords, {
                        color: '#2196F3',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 5'
                    }).addTo(map);
                }
            }
        }
        
        function updateStats() {
            const filtered = getFilteredOrders();
            const geocoded = filtered.filter(o => o.lat && o.lon).length;
            
            document.getElementById('total-orders').textContent = filtered.length;
            document.getElementById('geocoded-count').textContent = geocoded;
            document.getElementById('ordered-count').textContent = orderedStops.length;
            
            document.getElementById('calculate-route-btn').disabled = orderedStops.length < 2;
            document.getElementById('copy-list-btn').disabled = orderedStops.length === 0;
            document.getElementById('export-csv-btn').disabled = orders.length === 0;
        }
        
        document.querySelectorAll('.checkbox-group input').forEach(cb => {
            cb.addEventListener('change', () => { 
                renderOrders(); 
                updateMap(); 
                updateStats(); 
            });
        });
        
        // √öJ: Lista m√°sol√°sa funkcionalit√°s
        document.getElementById('copy-list-btn').addEventListener('click', () => {
            const orderedList = orderedStops
                .map((orderNum, index) => {
                    const order = orders.find(o => o.orderNumber === orderNum);
                    return `${index + 1}. ${order.name} - ${order.phone} - ${order.address}`;
                })
                .join('\n');
            
            navigator.clipboard.writeText(orderedList).then(() => {
                alert('‚úÖ Lista v√°g√≥lapra m√°solva!');
            });
        });
        
        // √öJ: CSV export√°l√°s
        document.getElementById('export-csv-btn').addEventListener('click', () => {
            const csvRows = [
                ['Sorsz√°m', 'Rendel√©ssz√°m', 'N√©v', 'Telefon', 'Utca', 'V√°ros', 'Ir√°ny√≠t√≥sz√°m', 'Teljes c√≠m', 'St√°tusz', 'Latitude', 'Longitude']
            ];
            
            orderedStops.forEach((orderNum, index) => {
                const order = orders.find(o => o.orderNumber === orderNum);
                csvRows.push([
                    index + 1,
                    order.orderNumber,
                    order.name,
                    order.phone,
                    order.addressSegments.street,
                    order.addressSegments.city,
                    order.addressSegments.postcode,
                    order.address,
                    order.status,
                    order.lat || '',
                    order.lon || ''
                ]);
            });
            
            const csvContent = csvRows.map(row => row.join(';')).join('\n');
            const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `bug-palace-szallitas-${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
        });
        
        window.addEventListener('load', initMap);
        
        // √öJ: √ötvonal optimaliz√°l√°s (egyszer≈± verzi√≥ - t√°vols√°g alapj√°n)
        document.getElementById('calculate-route-btn').addEventListener('click', async () => {
            if (orderedStops.length < 2) return;
            
            const btn = document.getElementById('calculate-route-btn');
            btn.textContent = '‚è≥ Sz√°m√≠t√°s...';
            btn.disabled = true;
            
            // Nearest neighbor algorithm (moh√≥ √∫tvonal optimaliz√°l√°s)
            const orderedCoords = orderedStops.map(orderNum => {
                const order = orders.find(o => o.orderNumber === orderNum);
                return { orderNum, lat: order.lat, lon: order.lon };
            }).filter(o => o.lat && o.lon);
            
            if (orderedCoords.length < 2) {
                btn.textContent = 'üó∫Ô∏è √ötvonal optimaliz√°l√°sa';
                btn.disabled = false;
                return;
            }
            
            // T√°vols√°g sz√°m√≠t√°s (Haversine)
            function distance(coord1, coord2) {
                const R = 6371; // km
                const dLat = (coord2.lat - coord1.lat) * Math.PI / 180;
                const dLon = (coord2.lon - coord1.lon) * Math.PI / 180;
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(coord1.lat * Math.PI / 180) * Math.cos(coord2.lat * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            }
            
            // Nearest neighbor
            const optimized = [orderedCoords[0]];
            const remaining = orderedCoords.slice(1);
            
            while (remaining.length > 0) {
                const current = optimized[optimized.length - 1];
                let nearest = 0;
                let minDist = distance(current, remaining[0]);
                
                for (let i = 1; i < remaining.length; i++) {
                    const dist = distance(current, remaining[i]);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = i;
                    }
                }
                
                optimized.push(remaining[nearest]);
                remaining.splice(nearest, 1);
            }
            
            // Friss√≠tj√ºk a sorrendet
            orderedStops = optimized.map(o => o.orderNum);
            
            btn.textContent = 'üó∫Ô∏è √ötvonal optimaliz√°l√°sa';
            btn.disabled = false;
            
            renderOrders();
            updateMap();
            updateStats();
            
            alert('‚úÖ √ötvonal optimaliz√°lva a legr√∂videbb t√°vols√°gra!');
        });
    </script>
</body>
</html>
