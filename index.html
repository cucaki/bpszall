<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bug Palace - Rendel√©s T√©rk√©p</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .upload-section {
            margin: 20px 0;
        }
        
        .file-input-wrapper {
            display: inline-block;
            position: relative;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s;
        }
        
        .file-input-label:hover {
            background: #45a049;
        }
        
        .file-name {
            margin-left: 15px;
            color: #666;
        }
        
        .info-box {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 14px;
            color: #1976d2;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .sidebar {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .filters {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .filter-group {
            margin-bottom: 15px;
        }
        
        .filter-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .checkbox-item label {
            font-weight: normal;
            cursor: pointer;
        }
        
        .order-list {
            margin-top: 20px;
        }
        
        .order-item {
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }
        
        .order-item:hover {
            border-color: #4CAF50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .order-item.selected {
            border-color: #4CAF50;
            background: #f1f8f4;
        }
        
        .order-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 6px;
        }
        
        .status-teljesitve {
            background: #C6EFCE;
            color: #155724;
        }
        
        .status-feldolgozas {
            background: #FFEB9C;
            color: #856404;
        }
        
        .status-fizetes-folyamatban {
            background: #DDEBF7;
            color: #004085;
        }
        
        .status-fizetes-elott {
            background: #FFC7CE;
            color: #721c24;
        }
        
        .order-name {
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .order-address, .order-phone {
            font-size: 13px;
            color: #666;
            margin-bottom: 2px;
        }
        
        .map-container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        #map {
            height: calc(100vh - 200px);
            min-height: 400px;
        }
        
        .action-buttons {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .btn-primary {
            background: #2196F3;
            color: white;
        }
        
        .btn-primary:hover {
            background: #1976D2;
        }
        
        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn-success {
            background: #4CAF50;
            color: white;
        }
        
        .btn-success:hover {
            background: #45a049;
        }
        
        .btn-success:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .stats {
            background: #f9f9f9;
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 13px;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .stats-label {
            font-weight: 600;
        }
        
        .no-data {
            text-align: center;
            padding: 40px;
            color: #999;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .input-group select,
        .input-group input[type="time"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 14px;
        }
        
        .route-times {
            background: #fff9e6;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
            border: 2px solid #ffc107;
        }
        
        .time-entry {
            padding: 6px 0;
            border-bottom: 1px dashed #e0e0e0;
        }
        
        .time-entry:last-child {
            border-bottom: none;
        }
        
        @media print {
            body * {
                visibility: hidden;
            }
            #route-preview, #route-preview * {
                visibility: visible;
            }
            #route-preview {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üêõ Bug Palace - Sz√°ll√≠t√°si T√©rk√©p</h1>
            <p>T√∂ltsd fel a <strong>nyers WooCommerce export</strong> f√°jlt √©s tervezd meg az √∫tvonalat!</p>
            
            <div class="upload-section">
                <div class="file-input-wrapper">
                    <label class="file-input-label" for="file-upload">
                        üìÅ WooCommerce Excel kiv√°laszt√°sa
                    </label>
                    <input type="file" id="file-upload" accept=".xlsx, .xls">
                </div>
                <span class="file-name" id="file-name">Nincs f√°jl kiv√°lasztva</span>
                
                <div style="margin-top: 15px;">
                    <label for="start-point" style="font-weight: 600; display: block; margin-bottom: 8px;">
                        üìç Kezd≈ëpont (honnan indulsz √©s hova t√©rsz vissza):
                    </label>
                    <input 
                        type="text" 
                        id="start-point" 
                        placeholder="pl. Gyomaendr≈ëd, 5500"
                        style="width: 100%; max-width: 400px; padding: 10px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px;"
                        value="Gyomaendr≈ëd, 5500"
                    >
                </div>
                
                <div class="info-box">
                    ‚ÑπÔ∏è A nyers WooCommerce export automatikusan feldolgoz√°sra ker√ºl (csoportos√≠t√°s, t√©telek √∂sszef≈±z√©se, stb.)
                </div>
            </div>
        </header>
        
        <div class="main-content">
            <div class="sidebar">
                <div class="filters">
                    <div class="filter-group">
                        <label>Rendel√©s st√°tusza:</label>
                        <div class="checkbox-group">
                            <div class="checkbox-item">
                                <input type="checkbox" id="status-teljesitve" value="Teljes√≠tve">
                                <label for="status-teljesitve">Teljes√≠tve</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="status-feldolgozas" value="Feldolgoz√°s alatt" checked>
                                <label for="status-feldolgozas">Feldolgoz√°s alatt</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="status-fizetes-folyamatban" value="Fizet√©s folyamatban" checked>
                                <label for="status-fizetes-folyamatban">Fizet√©s folyamatban</label>
                            </div>
                            <div class="checkbox-item">
                                <input type="checkbox" id="status-fizetes-elott" value="Fizet√©s el≈ëtt" checked>
                                <label for="status-fizetes-elott">Fizet√©s el≈ëtt</label>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="stats" id="stats">
                    <div class="stats-row">
                        <span class="stats-label">√ñsszes rendel√©s:</span>
                        <span id="total-orders">0</span>
                    </div>
                    <div class="stats-row">
                        <span class="stats-label">Kiv√°lasztva:</span>
                        <span id="selected-orders">0</span>
                    </div>
                </div>
                
                <!-- Optimalized route preview -->
                <div id="route-preview" style="display: none; background: #f0f7ff; padding: 15px; border-radius: 6px; margin-top: 15px; border: 2px solid #2196F3;">
                    <div style="font-weight: 600; margin-bottom: 10px; color: #1976D2;">
                        üó∫Ô∏è Optimaliz√°lt √∫tvonal:
                    </div>
                    <div id="route-preview-content" style="font-size: 13px;">
                        <!-- Will be filled by JavaScript -->
                    </div>
                    
                    <!-- Route summary -->
                    <div id="route-summary" style="display: none; background: #e8f5e9; padding: 12px; border-radius: 6px; margin-top: 12px;">
                        <div style="font-weight: 600; color: #2e7d32; margin-bottom: 8px;">üìä √ñsszes√≠t√©s:</div>
                        <div style="font-size: 12px; color: #1b5e20;">
                            <div style="margin-bottom: 4px;">üöó Teljes t√°vols√°g: <strong><span id="total-distance">0</span> km</strong> (l√©gvonalban)</div>
                            <div style="margin-bottom: 4px;">‚è±Ô∏è Becs√ºlt id≈ë: <strong><span id="total-time">0</span> perc</strong> (10 perc/meg√°ll√≥)</div>
                            <div>üèÅ V√°rhat√≥ befejez√©s: <strong><span id="estimated-finish">-</span></strong></div>
                        </div>
                    </div>
                </div>
                
                <div class="action-buttons">
                    <div style="background: #f0f7ff; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                            <input type="checkbox" id="optimize-route" checked style="width: 18px; height: 18px;">
                            <span>
                                <strong>Optimaliz√°lt √∫tvonal</strong><br>
                                <small style="color: #666;">‚Ä¢ Kiv√°lasztott c√≠m ELS≈ê meg√°ll√≥<br>
                                ‚Ä¢ T√∂bbi: t√°vols√°g szerint hazafel√©<br>
                                ‚Ä¢ Vissza a kezd≈ëponthoz</small>
                            </span>
                        </label>
                        
                        <!-- First stop selector -->
                        <div id="first-stop-selector" style="display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid #ddd;">
                            <label for="first-stop-select" style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 13px;">
                                üéØ Els≈ë meg√°ll√≥ kiv√°laszt√°sa:
                            </label>
                            <select id="first-stop-select" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                                <option value="">Legt√°volabbi (automatikus)</option>
                            </select>
                        </div>
                        
                        <!-- Start time selector -->
                        <div id="start-time-selector" style="display: none; margin-top: 12px; padding-top: 12px; border-top: 1px solid #ddd;">
                            <label for="start-time-input" style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 13px;">
                                üïê Indul√°si id≈ëpont:
                            </label>
                            <input type="time" id="start-time-input" value="09:00" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 13px;">
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" id="plan-route-btn" disabled>
                        üó∫Ô∏è √ötvonal tervez√©se (Google Maps)
                    </button>
                    <button class="btn btn-success" id="export-route-btn" disabled>
                        üìÑ √ötvonal export√°l√°sa (CSV)
                    </button>
                    <button class="btn btn-primary" id="print-route-btn" disabled>
                        üñ®Ô∏è √ötvonallap nyomtat√°sa
                    </button>
                    <button class="btn btn-primary" id="select-all-btn" disabled>
                        ‚úì √ñsszes kijel√∂l√©se
                    </button>
                    <button class="btn btn-primary" id="deselect-all-btn" disabled>
                        ‚úó Kijel√∂l√©sek t√∂rl√©se
                    </button>
                </div>
                
                <div class="order-list" id="order-list">
                    <div class="no-data">
                        T√∂lts fel egy WooCommerce export f√°jlt a kezd√©shez
                    </div>
                </div>
            </div>
            
            <div class="map-container">
                <div id="map"></div>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- SheetJS for Excel reading -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    
    <script>
        // Global variables
        let map;
        let markers = [];
        let orders = [];
        let selectedOrders = new Set();
        
        // Initialize map
        function initMap() {
            map = L.map('map').setView([47.1625, 19.5033], 7); // Hungary center
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
        }
        
        // Status color mapping
        function getStatusClass(status) {
            const statusMap = {
                'Teljes√≠tve': 'status-teljesitve',
                'Feldolgoz√°s alatt': 'status-feldolgozas',
                'Fizet√©s folyamatban': 'status-fizetes-folyamatban',
                'Fizet√©s el≈ëtt': 'status-fizetes-elott'
            };
            return statusMap[status] || 'status-feldolgozas';
        }
        
        function getMarkerColor(status) {
            const colorMap = {
                'Teljes√≠tve': 'green',
                'Feldolgoz√°s alatt': 'orange',
                'Fizet√©s folyamatban': 'blue',
                'Fizet√©s el≈ëtt': 'red'
            };
            return colorMap[status] || 'gray';
        }
        
        // Find column dynamically
        function findColumn(columns, keywords) {
            return columns.find(col => {
                const colLower = col.toLowerCase();
                return keywords.every(kw => colLower.includes(kw.toLowerCase()));
            });
        }
        
        // Process raw WooCommerce export
        function processRawWooCommerce(rawData) {
            const columns = Object.keys(rawData[0]);
            
            // Find columns dynamically
            const orderNumberCol = findColumn(columns, ['order', 'number']);
            const orderDateCol = findColumn(columns, ['order', 'date']);
            const orderStatusCol = findColumn(columns, ['status']);
            const shippingFNameCol = findColumn(columns, ['first', 'shipping']);
            const shippingLNameCol = findColumn(columns, ['last', 'shipping']);
            const shippingAddrCol = findColumn(columns, ['address', 'shipping']);
            const shippingCityCol = findColumn(columns, ['city', 'shipping']);
            const shippingPostcodeCol = findColumn(columns, ['postcode', 'shipping']);
            const paymentCol = findColumn(columns, ['payment', 'method']);
            const totalCol = findColumn(columns, ['total', 'amount']);
            const itemNameCol = findColumn(columns, ['item', 'name']);
            const quantityCol = findColumn(columns, ['quantity']);
            
            // Phone (try shipping first, then billing)
            let phoneCol = findColumn(columns, ['phone', 'shipping']);
            if (!phoneCol) phoneCol = findColumn(columns, ['phone', 'billing']);
            
            // Customer note
            const noteCol = findColumn(columns, ['customer', 'note']);
            
            // Group by order number
            const grouped = {};
            
            rawData.forEach(row => {
                const orderNum = row[orderNumberCol];
                if (!orderNum) return;
                
                if (!grouped[orderNum]) {
                    grouped[orderNum] = {
                        orderNumber: orderNum,
                        date: row[orderDateCol],
                        status: row[orderStatusCol],
                        firstName: row[shippingFNameCol],
                        lastName: row[shippingLNameCol],
                        address: row[shippingAddrCol],
                        city: row[shippingCityCol],
                        postcode: row[shippingPostcodeCol],
                        phone: phoneCol ? row[phoneCol] : '',
                        payment: row[paymentCol],
                        total: row[totalCol],
                        note: noteCol ? row[noteCol] : '',
                        items: []
                    };
                }
                
                // Add item
                if (row[itemNameCol]) {
                    const qty = row[quantityCol] || 1;
                    grouped[orderNum].items.push(`${row[itemNameCol]} (${qty}x)`);
                }
            });
            
            // Convert to array and format
            const processed = Object.values(grouped).map(order => {
                // Format date: MM.DD HH:MM
                let formattedDate = '';
                if (order.date) {
                    const d = new Date(order.date);
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    const hours = String(d.getHours()).padStart(2, '0');
                    const minutes = String(d.getMinutes()).padStart(2, '0');
                    formattedDate = `${month}.${day} ${hours}:${minutes}`;
                }
                
                return {
                    orderNumber: order.orderNumber,
                    date: formattedDate,
                    status: order.status,
                    name: `${order.lastName} ${order.firstName}`.trim(),
                    phone: order.phone,
                    address: `${order.address}, ${order.city}, ${order.postcode}`.replace(/^,\s*/, '').replace(/,\s*$/, ''),
                    payment: order.payment,
                    price: order.total,
                    items: order.items.join(' | '),
                    note: order.note
                };
            });
            
            // Sort by date (newest first) - note: date is now string, so sort will be alphabetical which works for our format
            processed.sort((a, b) => b.date.localeCompare(a.date));
            
            return processed;
        }
        
        // Geocode address using Nominatim
        async function geocodeAddress(address) {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 5000); // 5 sec timeout
                
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address + ', Hungary')}&limit=1`,
                    { signal: controller.signal }
                );
                clearTimeout(timeout);
                
                const data = await response.json();
                if (data && data.length > 0) {
                    return {
                        lat: parseFloat(data[0].lat),
                        lon: parseFloat(data[0].lon)
                    };
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Geocoding timeout for:', address);
                } else {
                    console.error('Geocoding error:', error);
                }
            }
            return null;
        }
        
        // Calculate distance between two points (Haversine formula)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of Earth in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Calculate estimated time from distance (very rough estimate: assume 50km/h average speed + 10 min per stop)
        function estimateTravelTime(distanceKm) {
            return Math.round(distanceKm * 1.2); // 1.2 min per km (very conservative for city driving)
        }
        
        // Add minutes to time string
        function addMinutesToTime(timeStr, minutes) {
            const [hours, mins] = timeStr.split(':').map(Number);
            const date = new Date();
            date.setHours(hours, mins + minutes, 0, 0);
            return date.toTimeString().slice(0, 5);
        }
        
        // Read Excel file
        document.getElementById('file-upload').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            document.getElementById('file-name').textContent = file.name;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const rawData = XLSX.utils.sheet_to_json(firstSheet);
                    
                    // Show processing message
                    document.getElementById('order-list').innerHTML = '<div class="no-data">Rendel√©sek feldolgoz√°sa...</div>';
                    
                    // Process raw WooCommerce data
                    orders = processRawWooCommerce(rawData);
                    
                    console.log(`Feldolgozva ${orders.length} rendel√©s`);
                    
                    // Geocode addresses with progress
                    const progressDiv = document.createElement('div');
                    progressDiv.className = 'no-data';
                    progressDiv.innerHTML = `
                        <div>C√≠mek geok√≥dol√°sa...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                        </div>
                        <div><span id="geocode-progress">0</span>/${orders.length}</div>
                    `;
                    document.getElementById('order-list').innerHTML = '';
                    document.getElementById('order-list').appendChild(progressDiv);
                    
                    for (let i = 0; i < orders.length; i++) {
                        const order = orders[i];
                        const coords = await geocodeAddress(order.address);
                        if (coords) {
                            order.lat = coords.lat;
                            order.lon = coords.lon;
                        }
                        
                        // Update progress
                        const progress = ((i + 1) / orders.length * 100).toFixed(0);
                        document.getElementById('progress-fill').style.width = progress + '%';
                        document.getElementById('geocode-progress').textContent = i + 1;
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 1100));
                    }
                    
                    renderOrders();
                    updateMap();
                    updateStats();
                    
                    // Enable buttons
                    document.getElementById('select-all-btn').disabled = false;
                    document.getElementById('deselect-all-btn').disabled = false;
                    
                } catch (error) {
                    console.error('Error processing file:', error);
                    document.getElementById('order-list').innerHTML = '<div class="no-data" style="color: red;">Hiba a f√°jl feldolgoz√°sa sor√°n. Ellen≈ërizd hogy helyes WooCommerce export-e!</div>';
                }
            };
            
            reader.readAsArrayBuffer(file);
        });
        
        // Filter orders based on status checkboxes
        function getFilteredOrders() {
            const checkedStatuses = Array.from(document.querySelectorAll('.checkbox-group input[type="checkbox"]:checked'))
                .map(cb => cb.value);
            
            return orders.filter(order => checkedStatuses.includes(order.status));
        }
        
        // Render order list
        function renderOrders() {
            const filteredOrders = getFilteredOrders();
            const orderList = document.getElementById('order-list');
            
            if (filteredOrders.length === 0) {
                orderList.innerHTML = '<div class="no-data">Nincs megjelen√≠thet≈ë rendel√©s</div>';
                return;
            }
            
            orderList.innerHTML = '';
            
            filteredOrders.forEach(order => {
                const orderDiv = document.createElement('div');
                orderDiv.className = 'order-item';
                if (selectedOrders.has(order.orderNumber)) {
                    orderDiv.classList.add('selected');
                }
                
                orderDiv.innerHTML = `
                    <div class="order-status ${getStatusClass(order.status)}">${order.status}</div>
                    <div class="order-name">${order.name}</div>
                    <div class="order-phone">üìû ${order.phone}</div>
                    <div class="order-address">üìç ${order.address}</div>
                `;
                
                orderDiv.addEventListener('click', () => {
                    toggleOrderSelection(order.orderNumber);
                });
                
                orderList.appendChild(orderDiv);
            });
        }
        
        // Toggle order selection
        function toggleOrderSelection(orderNumber) {
            if (selectedOrders.has(orderNumber)) {
                selectedOrders.delete(orderNumber);
            } else {
                selectedOrders.add(orderNumber);
            }
            renderOrders();
            updateMap();
            updateStats();
            updateFirstStopSelector();
        }
        
        // Update first stop selector dropdown
        function updateFirstStopSelector() {
            const selected = orders.filter(o => selectedOrders.has(o.orderNumber));
            const selector = document.getElementById('first-stop-select');
            const container = document.getElementById('first-stop-selector');
            const optimizeEnabled = document.getElementById('optimize-route').checked;
            
            if (selected.length > 0 && optimizeEnabled) {
                container.style.display = 'block';
                
                // Rebuild options
                selector.innerHTML = '<option value="">Legt√°volabbi (automatikus)</option>';
                selected.forEach(order => {
                    const option = document.createElement('option');
                    option.value = order.orderNumber;
                    option.textContent = `${order.name} - ${order.address}`;
                    selector.appendChild(option);
                });
            } else {
                container.style.display = 'none';
            }
        }
        
        // Update map markers
        function updateMap() {
            // Clear existing markers
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            
            const filteredOrders = getFilteredOrders();
            
            if (filteredOrders.length === 0) return;
            
            filteredOrders.forEach(order => {
                if (order.lat && order.lon) {
                    const isSelected = selectedOrders.has(order.orderNumber);
                    const color = getMarkerColor(order.status);
                    
                    const icon = L.divIcon({
                        className: 'custom-marker',
                        html: `<div style="background-color: ${color}; width: ${isSelected ? '16px' : '12px'}; height: ${isSelected ? '16px' : '12px'}; border-radius: 50%; border: ${isSelected ? '3px' : '2px'} solid white; box-shadow: 0 0 4px rgba(0,0,0,0.5);"></div>`,
                        iconSize: [16, 16]
                    });
                    
                    const marker = L.marker([order.lat, order.lon], { icon })
                        .bindPopup(`
                            <strong>${order.name}</strong><br>
                            üìû ${order.phone}<br>
                            üìç ${order.address}<br>
                            <span style="background: ${color}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px;">${order.status}</span>
                            ${order.items ? '<br><br><strong>T√©telek:</strong><br>' + order.items : ''}
                            ${order.note ? '<br><br><strong>Megjegyz√©s:</strong><br>' + order.note : ''}
                        `)
                        .addTo(map);
                    
                    marker.on('click', () => {
                        toggleOrderSelection(order.orderNumber);
                    });
                    
                    markers.push(marker);
                }
            });
            
            // Fit map to markers
            if (markers.length > 0) {
                const group = L.featureGroup(markers);
                map.fitBounds(group.getBounds().pad(0.1));
            }
        }
        
        // Update stats
        function updateStats() {
            const filteredOrders = getFilteredOrders();
            document.getElementById('total-orders').textContent = filteredOrders.length;
            document.getElementById('selected-orders').textContent = selectedOrders.size;
            
            const hasSelection = selectedOrders.size > 0;
            document.getElementById('plan-route-btn').disabled = !hasSelection;
            document.getElementById('export-route-btn').disabled = !hasSelection;
            document.getElementById('print-route-btn').disabled = !hasSelection;
            
            // Show/hide time selector
            const optimizeEnabled = document.getElementById('optimize-route').checked;
            document.getElementById('start-time-selector').style.display = (hasSelection && optimizeEnabled) ? 'block' : 'none';
            
            // Update route preview
            updateRoutePreview();
        }
        
        // Get optimized route
        async function getOptimizedRoute() {
            const startPoint = document.getElementById('start-point').value.trim();
            const selected = orders.filter(o => selectedOrders.has(o.orderNumber));
            const firstStopOrderNum = document.getElementById('first-stop-select').value;
            const startTime = document.getElementById('start-time-input').value;
            
            if (!startPoint || selected.length === 0) return null;
            
            // Geocode start point
            const startCoords = await geocodeAddress(startPoint);
            if (!startCoords) return null;
            
            // Calculate distances
            const withDistances = selected
                .filter(o => o.lat && o.lon)
                .map(o => ({
                    ...o,
                    distance: calculateDistance(startCoords.lat, startCoords.lon, o.lat, o.lon)
                }));
            
            if (withDistances.length === 0) return null;
            
            let orderedStops;
            
            if (firstStopOrderNum) {
                // Manual first stop selection
                const firstStop = withDistances.find(o => o.orderNumber === firstStopOrderNum);
                const others = withDistances.filter(o => o.orderNumber !== firstStopOrderNum);
                
                if (firstStop) {
                    // Sort others by distance from first stop (descending)
                    others.forEach(o => {
                        o.distanceFromFirst = calculateDistance(firstStop.lat, firstStop.lon, o.lat, o.lon);
                    });
                    others.sort((a, b) => b.distanceFromFirst - a.distanceFromFirst);
                    
                    orderedStops = [firstStop, ...others];
                }
            } else {
                // Automatic: farthest first
                withDistances.sort((a, b) => b.distance - a.distance);
                orderedStops = withDistances;
            }
            
            // Calculate times and cumulative distances
            let cumulativeTime = 0;
            let totalDistance = 0;
            let currentTime = startTime;
            
            const route = orderedStops.map((stop, index) => {
                if (index === 0) {
                    // First stop: distance from start
                    const travelTime = estimateTravelTime(stop.distance);
                    currentTime = addMinutesToTime(currentTime, travelTime);
                    totalDistance += stop.distance;
                    cumulativeTime += travelTime + 10; // travel + 10 min stop
                } else {
                    // Subsequent stops: distance from previous
                    const prevStop = orderedStops[index - 1];
                    const dist = calculateDistance(prevStop.lat, prevStop.lon, stop.lat, stop.lon);
                    const travelTime = estimateTravelTime(dist);
                    currentTime = addMinutesToTime(currentTime, travelTime + 10); // previous stop time + travel
                    totalDistance += dist;
                    cumulativeTime += travelTime + 10;
                }
                
                return {
                    ...stop,
                    arrivalTime: currentTime,
                    index: index + 1
                };
            });
            
            // Calculate return distance
            if (orderedStops.length > 0) {
                const lastStop = orderedStops[orderedStops.length - 1];
                const returnDist = calculateDistance(lastStop.lat, lastStop.lon, startCoords.lat, startCoords.lon);
                totalDistance += returnDist;
                const returnTime = estimateTravelTime(returnDist);
                cumulativeTime += returnTime;
                currentTime = addMinutesToTime(currentTime, 10 + returnTime); // last stop time + return
            }
            
            return {
                route,
                totalDistance: totalDistance.toFixed(1),
                totalTime: cumulativeTime,
                finishTime: currentTime,
                startPoint,
                startTime
            };
        }
        
        // Update route preview panel
        async function updateRoutePreview() {
            const optimizeEnabled = document.getElementById('optimize-route').checked;
            const selected = orders.filter(o => selectedOrders.has(o.orderNumber));
            
            const previewDiv = document.getElementById('route-preview');
            const contentDiv = document.getElementById('route-preview-content');
            const summaryDiv = document.getElementById('route-summary');
            
            // Hide if optimization disabled or no selection
            if (!optimizeEnabled || selected.length === 0) {
                previewDiv.style.display = 'none';
                return;
            }
            
            // Show preview
            previewDiv.style.display = 'block';
            contentDiv.innerHTML = '<div style="color: #666;">√ötvonal sz√°m√≠t√°sa...</div>';
            summaryDiv.style.display = 'none';
            
            const routeData = await getOptimizedRoute();
            
            if (!routeData) {
                contentDiv.innerHTML = '<div style="color: #d32f2f;">‚ùå Nem siker√ºlt kisz√°molni az √∫tvonalat</div>';
                return;
            }
            
            const { route, totalDistance, totalTime, finishTime, startPoint, startTime } = routeData;
            
            // Build preview HTML
            let html = `
                <div style="padding: 8px; background: white; border-radius: 4px; margin-bottom: 8px;">
                    <strong>üèÅ START (${startTime}):</strong> ${startPoint}
                </div>
            `;
            
            route.forEach((stop, index) => {
                const emoji = index === 0 ? 'üéØ' : 'üìç';
                const bgColor = index === 0 ? '#fff3cd' : 'white';
                const label = index === 0 ? 'ELS≈ê meg√°ll√≥' : '';
                
                html += `
                    <div style="padding: 8px; background: ${bgColor}; border-radius: 4px; margin-bottom: 6px; border-left: 3px solid #2196F3;">
                        <div style="font-weight: 600; color: #1976D2;">
                            ${emoji} ${stop.index}. ${label}
                        </div>
                        <div style="margin-top: 4px; color: #f57c00; font-weight: 600;">
                            ‚è∞ √ârkez√©s: ${stop.arrivalTime}
                        </div>
                        <div style="margin-top: 4px;">
                            <strong>${stop.name}</strong>
                        </div>
                        <div style="color: #666; font-size: 12px;">
                            üìû ${stop.phone}
                        </div>
                        <div style="color: #666; font-size: 12px;">
                            üìç ${stop.address}
                        </div>
                        ${stop.items ? '<div style="color: #666; font-size: 11px; margin-top: 4px; padding-top: 4px; border-top: 1px dashed #ddd;">üì¶ ' + stop.items + '</div>' : ''}
                        ${stop.note ? '<div style="color: #e65100; font-size: 11px; margin-top: 4px;">üí¨ ' + stop.note + '</div>' : ''}
                    </div>
                `;
            });
            
            html += `
                <div style="padding: 8px; background: #c8e6c9; border-radius: 4px; margin-top: 8px;">
                    <strong>üè† VISSZA:</strong> ${startPoint}
                </div>
            `;
            
            contentDiv.innerHTML = html;
            
            // Show summary
            summaryDiv.style.display = 'block';
            document.getElementById('total-distance').textContent = totalDistance;
            document.getElementById('total-time').textContent = totalTime;
            document.getElementById('estimated-finish').textContent = finishTime;
        }
        
        // Plan route with Google Maps
        document.getElementById('plan-route-btn').addEventListener('click', async () => {
            const selected = orders.filter(o => selectedOrders.has(o.orderNumber));
            
            if (selected.length === 0) {
                alert('V√°lassz ki legal√°bb egy rendel√©st!');
                return;
            }
            
            if (selected.length > 25) {
                alert('Maximum 25 c√≠met adhatsz meg egyszerre a Google Maps-ben!');
                return;
            }
            
            const optimizeEnabled = document.getElementById('optimize-route').checked;
            const startPoint = document.getElementById('start-point').value.trim();
            
            if (optimizeEnabled && !startPoint) {
                alert('Add meg a kezd≈ëpontot az optimaliz√°l√°shoz!');
                return;
            }
            
            if (optimizeEnabled) {
                const routeData = await getOptimizedRoute();
                
                if (!routeData) {
                    alert('Nem siker√ºlt kisz√°molni az optimaliz√°lt √∫tvonalat!');
                    return;
                }
                
                const waypoints = routeData.route.map(o => encodeURIComponent(o.address));
                const url = `https://www.google.com/maps/dir/${encodeURIComponent(startPoint)}/${waypoints.join('/')}/${encodeURIComponent(startPoint)}/`;
                
                window.open(url, '_blank');
                
            } else {
                // Simple route (original functionality)
                const addresses = selected.map(o => encodeURIComponent(o.address));
                const url = `https://www.google.com/maps/dir/${addresses.join('/')}`;
                
                window.open(url, '_blank');
            }
        });
        
        // Export route to CSV
        document.getElementById('export-route-btn').addEventListener('click', async () => {
            const routeData = await getOptimizedRoute();
            
            if (!routeData) {
                alert('Nem siker√ºlt kisz√°molni az √∫tvonalat!');
                return;
            }
            
            // Build CSV
            let csv = 'Sorsz√°m,√ârkez√©s,N√©v,Telefon,C√≠m,T√©telek,Megjegyz√©s\n';
            
            routeData.route.forEach(stop => {
                csv += `${stop.index},"${stop.arrivalTime}","${stop.name}","${stop.phone}","${stop.address}","${stop.items || ''}","${stop.note || ''}"\n`;
            });
            
            // Add summary
            csv += '\n';
            csv += `√ñsszesen,,,,,${routeData.totalDistance} km,${routeData.totalTime} perc\n`;
            csv += `Befejez√©s,${routeData.finishTime},,,,\n`;
            
            // Download
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `utvonal_${new Date().toISOString().slice(0,10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
        
        // Print route
        document.getElementById('print-route-btn').addEventListener('click', () => {
            window.print();
        });
        
        // Select all
        document.getElementById('select-all-btn').addEventListener('click', () => {
            const filteredOrders = getFilteredOrders();
            filteredOrders.forEach(order => selectedOrders.add(order.orderNumber));
            renderOrders();
            updateMap();
            updateStats();
            updateFirstStopSelector();
        });
        
        // Deselect all
        document.getElementById('deselect-all-btn').addEventListener('click', () => {
            selectedOrders.clear();
            renderOrders();
            updateMap();
            updateStats();
            updateFirstStopSelector();
        });
        
        // Status filter change
        document.querySelectorAll('.checkbox-group input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                renderOrders();
                updateMap();
                updateStats();
            });
        });
        
        // Optimization checkbox change
        document.getElementById('optimize-route').addEventListener('change', () => {
            updateStats();
            updateFirstStopSelector();
        });
        
        // First stop selector change
        document.getElementById('first-stop-select').addEventListener('change', () => {
            updateRoutePreview();
        });
        
        // Start time input change
        document.getElementById('start-time-input').addEventListener('change', () => {
            updateRoutePreview();
        });
        
        // Start point input change
        document.getElementById('start-point').addEventListener('input', () => {
            // Debounce the preview update
            clearTimeout(window.startPointTimeout);
            window.startPointTimeout = setTimeout(() => {
                updateRoutePreview();
            }, 1000);
        });
        
        // Initialize
        initMap();
    </script>
</body>
</html>
